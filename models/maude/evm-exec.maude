--- EVM Execution
--- =============

--- Local State
--- -----------

fmod EVM-LOCALSTATE is
    including NAT .

    sort Word .
    subsort Word < Nat .
    sorts WordStack WordStack? .
    subsort WordStack < WordStack? .

    sorts Mem MemAddr MemRange .
    subsorts Nat < MemAddr .

    sort LocalState .
    sorts StackOp LocalOp .
    subsort StackOp < LocalOp .

    var N : Nat .
    ceq N = N rem (2 ^ 256) if N > (2 ^ 256) .
    cmb N : Word if N < (2 ^ 256) .
    --- this seems like an expensive membership check

--- ### Word Stack

    op .WordStack : -> WordStack [ctor] .
    op _:_        : Word    WordStack -> WordStack [ctor] .
    op _[_]       : StackOp WordStack -> WordStack .

    op stackSize : WordStack -> Nat .
    var W : Word . var WS : WordStack .
    -----------------------------------
    eq stackSize(.WordStack) = 0 .
    eq stackSize(W : WS)     = s(stackSize(WS)) .

    var WS? : WordStack? .
    ----------------------
    cmb WS? : WordStack if stackSize(WS?) <= 1024 .

    ops ADD MUL SUB EXP DIV MOD SDIV SMOD ADDMOD MULMOD SIGNEXTEND LT GT SLT SGT
        EQ ISZERO AND OR XOR NOT BYTE SHA3 POP : -> StackOp .

    vars V0 V1 V2 : Word .
    var  VS       : WordStack .

    eq ADD [ V0 : V1 : VS ] = (V0 + V1) : VS .
    --- eq SUB [ V0 : V1 : VS ] = (V0 - V1) : VS .
    eq MUL [ V0 : V1 : VS ] = (V0 * V1) : VS .
    eq EXP [ V0 : V1 : VS ] = (V0 ^ V1) : VS .
    eq DIV [ V0 : V1 : VS ] = (if V1 == 0 then 0 else (V0 quo V1) fi) : VS .
    eq MOD [ V0 : V1 : VS ] = (if V1 == 0 then 0 else (V0 rem V1) fi) : VS .
    eq ADDMOD [ V0 : V1 : V2 : VS ] = (if V2 == 0 then 0 else (V0 + V1) rem V2 fi) : VS .
    eq MULMOD [ V0 : V1 : V2 : VS ] = (if V2 == 0 then 0 else (V0 * V1) rem V2 fi) : VS .

    --- eq SDIV [ V0 : V1 : VS ] = sdiv(V0,V1) : VS .
    --- eq SMOD [ V0 : V1 : VS ] = smod(V0,V1) : VS .
    --- eq SIGNEXTEND [ V0 : V1 : VS ] = signextend(V0,V1) : VS .

    eq LT     [ V0 : V1 : VS ] = (if V0 < V1 then 1 else 0 fi) : VS .
    eq GT     [ V0 : V1 : VS ] = (if V0 > V1 then 1 else 0 fi) : VS .
    --- eq SLT    [ V0 : V1 : VS ] = slt(V0,V1) : VS .
    --- eq SGT    [ V0 : V1 : VS ] = sgt(V0,V1) : VS .
    eq EQ     [ V0 : V1 : VS ] = (if V0 == V1 then 1 else 0 fi) : VS .
    eq ISZERO [ V0 : VS ]      = (if V0 == 0 then 1 else 0 fi) : VS .

    --- eq NOT [ V0 : VS ]      = not(V0)     : VS .
    --- eq OR  [ V0 : V1 : VS ] = or(V0, V1)  : VS .
    --- eq AND [ V0 : V1 : VS ] = and(V0, V1) : VS .
    --- eq XOR [ V0 : V1 : VS ] = xor(V0, V1) : VS .
    --- These are bit-wise operators.

    --- eq BYTE [ V0 : V1 : VS ] = byte(V0, V1) : VS .
    --- eq SHA3 [ V0 : V1 : VS ] = sha3(V0, V1) : VS .

    eq POP [ V0 : VS ] = VS .

--- ### Local Memory

    op mt   : -> Mem .
    op __   : Word Mem -> Mem [prec 40] .
    -------------------------------------
    vars V V' : Word .
    vars A A' : Word .
    vars M M' : Mem .

    op _[_]    : Mem Word -> Word .
    op _[_:=_] : Mem Word Word -> Mem .
    -----------------------------------
    eq mt[A]             = 0 .
    eq (V M)[0]          = V .
    eq (V M)[s(A)]       = M[A] .
    eq (V M)[0 := V']    = V' M .
    eq (V M)[s(A) := V'] = V (M[A := V']) .

    op drop : Word Mem -> Mem .
    op take : Word Mem -> Mem .
    op _++_ : Mem Mem  -> Mem [prec 50] .
    ---------------------------
    eq drop(0, M)      = M .
    eq drop(A, mt)     = mt .
    eq drop(s(A), V M) = drop(A,M) .
    eq take(0, M)      = mt .
    eq take(s(A), mt)  = 0 take(A, mt) .
    eq take(s(A), V M) = V take(A, M) .
    eq mt ++ M         = M .
    eq M ++ mt         = M .
    eq (V M) ++ M      = V (M ++ M) .

    op _.._    : Word Word -> MemRange .
    op _[_]    : Mem MemRange -> Mem .
    op _[_:=_] : Mem MemRange Mem -> Mem .
    --------------------------------------
    eq M[A .. A']       = if A < A' then take(sd(A,A'), drop(A,M)) else mt fi .
    eq M[A .. A' := M'] = if A < A' then take(A,M) ++ (take(sd(A,A'), M') ++ drop(A', M)) else M fi .

--- ### Local State (Stack and Memory)

    op <_|_> : WordStack Mem -> LocalState .
    op _[_]  : LocalOp LocalState -> [LocalState] .
    -----------------------------------------------
    var SO : StackOp .
    eq SO [ < VS | M > ] = < SO [ VS ] | M > .

    --- all of these decrease/leave-same stack size
    ops MLOAD MSTORE MSTORE8 : -> LocalOp .
    ---------------------------------------
    eq MLOAD  [ < V0 : VS      | M > ] = < M[V0] : VS | M > .
    eq MSTORE [ < V0 : V1 : VS | M > ] = < VS         | M[V0 := V1] > .
    --- eq MSTORE8 [ < VS | M > ]      = mstore8(VS,M) .
endfm

--- Global State
--- ------------

fmod EVM-ACCOUNTEXEC-STATE is
    protecting NAT .
    protecting EVM-LOCALSTATE .
    --- protecting EVM-ACCOUNTSTATE .

    sort Address .
    subsort Nat < Address .
    sort PC .
    sort AccountExecState .
    sort GlobalState .

    sorts StorageOp GlobalOp OpCode Program .
    subsort StorageOp < GlobalOp .
    subsorts GlobalOp LocalOp < OpCode < Program .

    sorts CallFrame CallStack .

    op pc : Nat -> PC .

    op skip : -> Program [ctor] .
    op _:_  : Nat OpCode -> Program .
    op _;_  : Program Program -> Program [assoc comm id: skip prec 60] .

    op _,_,_     : Program PC LocalState -> AccountExecState .
    op <_,_|_>   : Nat Address AccountExecState -> CallFrame .
    op <_,_,_|_> : Nat Address OpCode AccountExecState -> CallFrame .

    var FN : Nat . var ID : Address .
    var OP : OpCode . var pc : Nat . var P : Program .
    var LS : LocalState . var PC : PC . var LOP : LocalOp .

    eq    < FN , ID      | (pc : OP ; P) , pc(pc)     , LS >
        = < FN , ID , OP | (pc : OP ; P) , pc(pc + 1) , LS > .

    eq    < FN , ID , LOP | P , PC , LS      >
        = < FN , ID       | P , PC , LOP[LS] > .

    op .CallStack : -> CallStack [ctor] .
    op _:_        : CallFrame CallStack -> CallStack [ctor] .

    op _[_]       : OpCode CallFrame -> [CallFrame] .

    ops SLOAD SSTORE : -> StorageOp .

    --- control flow
    ops JUMP JUMP1 JUMPDEST CREATE CALL CALLCODE RETURN DELEGATECALL SUICIDE : -> LocalOp .

    --- all of these increase stack-size by 1
    op PUSH[_] : Nat -> LocalOp .
    op DUP[_]  : Nat -> LocalOp .
    op SWAP[_] : Nat -> LocalOp .
    --- PUSH[1-32], DUP[1-16], SWAP[1-16]
endfm

--- EVM State
--- ---------

fmod EVM-STATE is
    protecting NAT .
    protecting EVM-LOCALSTATE .

    sort PC .
    subsort Nat < PC .
    sorts OpCode Program .
    subsort LocalOp < OpCode < Program .

    sorts CallID CallState CallFrame CallStack .

    op <_,_|_> : Program PC LocalState -> CallState .

    op pc : Nat -> PC .

    op <_|_> : CallID CallState -> CallFrame .

    op .CallStack : -> CallStack .
    op _:_        : CallFrame CallStack -> CallStack .
endfm

fmod EVM-EXEC is
    extending EVM-STATE .

    ops PC GAS GASLIMIT MSIZE 

    --- accessors
    ops ADDRESS BALANCE ORIGIN CALLER CALLVALUE CALLDATALOAD CALLDATASIZE
        CALLDATACOPY CODESIZE CODECOPY GASPRICE EXTCODESIZE EXTCODECOPY
        MSIZE BLOCKHASH COINBASE TIMESTAMP NUMBER DIFFICULTY GASLIMIT PC GAS
        : -> OpCode .

    op LOG[_]  : Nat -> OpCode .
    --- LOG[0-4]


    op skip : -> Program .
    op _:_  : Nat OpCode -> Program .
    op _;_  : Program Program -> Program [assoc comm id: skip] .
endfm
