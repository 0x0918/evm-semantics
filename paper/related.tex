\section{Related Work}
Formal verification of programming languages is not a particularly new idea,
and our design decisions presented in this work are certainly influenced by
prior work in this area. For example, \K{} semantics exist for several large languages, most notably
C~\cite{ellison-2012-thesis}, Java~\cite{bogdanas-rosu-2015-popl}, and
JavaScript~\cite{park-stefanescu-rosu-2015-pldi}, as well as for many smaller languages. These semantics are
continuously refined as bugs are found, either in the original language
specification or in the \K{} implementation. By providing an executable and
testable specification of a language semantics, language design issues can be
uncovered and fixed early. Additionally, tools for checking for common bugs and
program errors can be developed to steer developers away from these pitfalls.
For example, C has a large amount of undefined and implementation defined
behavior, which is documented in a \K{} definition so that developers can be
informed when their program may include such behavior
\cite{guth-hathhorn-saxena-rosu-2016-cav}.

There has been recent effort and interest in formally verifying properties of
smart contracts. Luu et~al.~\cite{luumaking} formalized a subset of the EVM,
called EtherLite, and built a symbolic execution tool to check for common bugs
in smart contracts. Why3 is a tool included in the Solidity IDE that supplies
formal verification of Solidity contracts. Bhargavan et~al.\cite{evmf*} propose a method for formally
verifying EVM smart contracts by converting Solidity programs or EVM bytecode to
F*, a functional programming language focused on program verification.
