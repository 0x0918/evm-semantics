\section{Methodology}

We used K and modeled the EVM, to say interesting things about EVM programs.

\subsection{Language Independent Program Verification}

Developing new tools for each new language is labor intensive and bug-prone. To
avoid some of the start-up cost of formal verification in a new language, \K
defines its tools parametrically over the input language~\cite{inproceedings}.
From the syntax and operational semantics of a language, parsers, interpreters,
debuggers, and verifiers are derived. This infrastructure is developed and
debugged once, and then instantiated to specific languages. The instantiation
requires describing for \K the way that execution state looks in your language
(the \textit{configuration}), then describing how simplification in your
language happens over that state (as transition \textit{rules}).

\subsection{EVM Execution State}

The state of EVM is broken into two components: the local state of an active
transaction (smart contract execution), and the state of the network as a whole
(account information). To mirror this, our configuration consists of two
subconfigurations.

\subsubsection{Transaction Execution}

Each transation has an associated account, a program counter, a word-stack, and
a volatile local memory.

\begin{verbatim}
<k> ... </k>
<id> ... </id>
<pc> ... </pc>
<wordStack> ... </wordStack>
<localMem> ... </localMem>
<callStack> ... </callStack>
\end{verbatim}

The \texttt{<k>} cell holds the next execution step of the EVM.  The
\texttt{<id>} cell holds the ID of the account the EVM contract belongs to and
the \texttt{<pc>} cell holds the current program counter. The
\texttt{<wordStack>} is the simple stack available to the EVM program being
executed, and the \texttt{<localMem>} cell holds the volatile auxiliary memory
available to the program. The \texttt{<callStack>} cell records the calls made
across a transaction.

\subsubsection{Network State}

The network is modelled as a map from account ids to their associated program,
cold storage, and current balance. This can be thought of as the blockchain
state at any given time.

\begin{verbatim}
<accounts>
    <account multiplicity="*">
        <acctID> .AcctID </acctID>
        <program> .Map </program>
        <storage> .Map </storage>
        <balance> 0:Word </balance>
    </account>
</accounts>
\end{verbatim}

The \texttt{<accounts>} cell holds information about the accounts on the block
chain. Each \texttt{<account>} holds the program associated with it in the
\texttt{<program>} cell, its permanent storage in the \texttt{<storage>} cell,
and the balance associated with the account in the \texttt{<balance>} cell.

\subsection{EVM Execution Rules}

EVM smart contracts consist of a sequence of commands for effecting the local
execution state and the global network state. Commands are grouped using \K's
sorts; for example we have the \texttt{StackOp} sort for stack operators, the
\texttt{ControlFlowOp} sort for operations which affect control flow (eg.
calling other contracts), and the \texttt{LocalOp} sort for other operations
that may effect the local transaction state. At the point of writing, we have
implemented almost 60\% of the EVM opcodes.

Semantics of EVM instructions and provided using the Ethereum Yellow Paper as a
reference~\cite{gavwood}. They are provided as \K rules over the execution
state. For example, the rules for \texttt{MLOAD} and \texttt{MSTORE}:

\begin{verbatim}
rule <k> MSTORE => #updateLocalMem INDEX VALUE ... </k>
     <wordStack> INDEX : VALUE : WS => WS </wordStack>

rule <k> MLOAD => . ... </k>
     <wordStack> INDEX : WS => VALUE : WS </wordStack>
     <localMem>... INDEX |-> VALUE ...</localMem>
\end{verbatim}

The first rule states that if the next instruction is \texttt{MSTORE}, and the
top two elements of the word stack are \texttt{INDEX} and \texttt{VALUE}, then
they should be removed from the stack and the next instruction should be
\texttt{\#updateLocalMem INDEX VALUE} (an auxiliary internal command for working
with the local memory).

The second rule states that if the next instruction is \texttt{MLOAD}, and the
top element of the stack is \texttt{INDEX}, and somewhere in the local memory we
have the binding \texttt{INDEX |-> VALUE}, then \texttt{INDEX} should be
replaced with \texttt{VALUE} on the stack. Notice that we take advantage of \K's
\textit{configuration abstraction}, which allows each rule to only specify the
parts of the state relevant to it.

\subsubsection{Intercontract Execution}

EVM allows contracts to call each other, accounting for the rich dynamics
possible in the Ethereum network but also providing a wealth of potential bugs
and pitfalls in contract design. The next two rules model one contract making a
\texttt{CALL} to another.

\begin{verbatim}
rule <k> CALL => #processCall { ACCT | ETHER | #range(LM, INIT, SIZE) } ... </k>
     <wordStack> ACCT : ETHER : INIT : SIZE : WS => WS </wordStack>
     <localMem> LM </localMem>
\end{verbatim}

First, we gather the arguments to \texttt{CALL}, which consists of which process
to call (\texttt{ACCT}), the amount of Ether to transfer (\texttt{ETHER}), and
the region of locale memory to use as arguments (\texttt{\#range(LM, INIT,
SIZE)}). \texttt{\#processCall} is used as an internal command which has the
following effects:

\begin{verbatim}
rule <k> #processCall {ACCT | ETHER | WL}
      =>    #decreaseAcctBalance CURRACCT ETHER
         ~> #increaseAcctBalance ACCT ETHER
         ~> #pushCallStack
         ~> #setProcess {ACCT | 0 | .WordStack | #asMap(WL)}
     ... </k>
     <id> CURRACCT </id>
\end{verbatim}

First the current accounts balance is reduced (\texttt{\#decreaseAcctBalance
CURRACCT ETHER}), then the callee's account balance is increased, the current
execution state is pushed onto the \texttt{<callStack>} using internal command
\texttt{\#pushCallStack}, and the callee is set as the current process. The
operator \texttt{~>} can be read as "followed by", similar to the semicolon in
many programming languages.


\todo{Something about function calls}

\todo{Everett, Manasvi}
