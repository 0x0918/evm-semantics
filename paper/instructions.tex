After designing our K configuration, we then implemented a large subset of the
EVM instructions detailed in the Ethereum Yellow Paper~\cite{gavwood}. At the
point of writing, we have implemented almost 60\% of the instructions in EVM,
and can run a vast number of EVM programs using our subset of instructions. In
this section, we discuss the classes of instructions we have already implemented, as
well as outstanding instructions that need to be implemented.

Throughout the model, we implement several classes of instructions. The first
kind of instruction deals with operations on the stack. We group instructions
based on how many elements they pull off of the stack, for example, a
\textit{BinaryStackOperation} pulls two elements off of the stack, performs some
computation on those elements, and then pushes the elements back onto the stack.

Other instructions may use the word stack but also make use of other parts of
the K configuration, for example, the program counter or local memory. A JUMP
instruction touches the program counter to jump to previous instructions; a MLOAD
instruction will load a word from a program\textquotesingle s local memory and move it to the
stack.

\todo{Something about function calls}
